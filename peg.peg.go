// Code generated by peg -inline -switch peg.peg. DO NOT EDIT.

// PE Grammar for PE Grammars
//
// Adapted from [1] by Ian Piumarta <first-name at last-name point com>.
//
// Best viewed using 140 columns monospaced with tabs every 8.
//
// [1] Bryan Ford.  "Parsing Expression Grammars: A Recognition-Based Syntactic
//     Foundation."  Symposium on Principles of Programming Languages,
//     January 14--16, 2004, Venice, Italy.

package main

import (
	"bytes"
	"fmt"
	"github.com/pointlander/peg/tree"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleGrammar
	ruleImport
	ruleSingleImport
	ruleMultiImport
	ruleImportName
	ruleDefinition
	ruleExpression
	ruleSequence
	rulePrefix
	ruleSuffix
	rulePrimary
	ruleIdentifier
	ruleIdentStart
	ruleIdentCont
	ruleLiteral
	ruleClass
	ruleRanges
	ruleDoubleRanges
	ruleRange
	ruleDoubleRange
	ruleChar
	ruleDoubleChar
	ruleEscape
	ruleLeftArrow
	ruleSlash
	ruleAnd
	ruleNot
	ruleQuestion
	ruleStar
	rulePlus
	ruleOpen
	ruleClose
	ruleDot
	ruleSpaceComment
	ruleSpacing
	ruleMustSpacing
	ruleComment
	ruleSpace
	ruleHeader
	ruleHeaderSpaceComment
	ruleHeaderComment
	ruleEndOfLine
	ruleEndOfFile
	ruleAction
	ruleActionBody
	ruleBegin
	ruleEnd
	ruleAction0
	ruleAction1
	ruleAction2
	rulePegText
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
)

var rul3s = [...]string{
	"Unknown",
	"Grammar",
	"Import",
	"SingleImport",
	"MultiImport",
	"ImportName",
	"Definition",
	"Expression",
	"Sequence",
	"Prefix",
	"Suffix",
	"Primary",
	"Identifier",
	"IdentStart",
	"IdentCont",
	"Literal",
	"Class",
	"Ranges",
	"DoubleRanges",
	"Range",
	"DoubleRange",
	"Char",
	"DoubleChar",
	"Escape",
	"LeftArrow",
	"Slash",
	"And",
	"Not",
	"Question",
	"Star",
	"Plus",
	"Open",
	"Close",
	"Dot",
	"SpaceComment",
	"Spacing",
	"MustSpacing",
	"Comment",
	"Space",
	"Header",
	"HeaderSpaceComment",
	"HeaderComment",
	"EndOfLine",
	"EndOfFile",
	"Action",
	"ActionBody",
	"Begin",
	"End",
	"Action0",
	"Action1",
	"Action2",
	"PegText",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for range depth {
				fmt.Fprint(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string([]rune(buffer)[node.begin:node.end]))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type Peg struct {
	*tree.Tree

	Buffer         string
	buffer         []rune
	rules          [100]func() bool
	parse          func(rule ...int) error
	reset          func()
	Pretty         bool
	disableMemoize bool
	tokens32
}

func (p *Peg) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *Peg) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *Peg
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *Peg) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *Peg) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *Peg) SprintSyntaxTree() string {
	var b bytes.Buffer
	p.WriteSyntaxTree(&b)
	return b.String()
}

func (p *Peg) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.AddPackage(text)
		case ruleAction1:
			p.AddPeg(text)
		case ruleAction2:
			p.AddState(text)
		case ruleAction3:
			p.AddImport(text)
		case ruleAction4:
			p.AddRule(text)
		case ruleAction5:
			p.AddExpression()
		case ruleAction6:
			p.AddAlternate()
		case ruleAction7:
			p.AddNil()
			p.AddAlternate()
		case ruleAction8:
			p.AddNil()
		case ruleAction9:
			p.AddSequence()
		case ruleAction10:
			p.AddPredicate(text)
		case ruleAction11:
			p.AddStateChange(text)
		case ruleAction12:
			p.AddPeekFor()
		case ruleAction13:
			p.AddPeekNot()
		case ruleAction14:
			p.AddQuery()
		case ruleAction15:
			p.AddStar()
		case ruleAction16:
			p.AddPlus()
		case ruleAction17:
			p.AddName(text)
		case ruleAction18:
			p.AddDot()
		case ruleAction19:
			p.AddAction(text)
		case ruleAction20:
			p.AddPush()
		case ruleAction21:
			p.AddSequence()
		case ruleAction22:
			p.AddSequence()
		case ruleAction23:
			p.AddPeekNot()
			p.AddDot()
			p.AddSequence()
		case ruleAction24:
			p.AddPeekNot()
			p.AddDot()
			p.AddSequence()
		case ruleAction25:
			p.AddAlternate()
		case ruleAction26:
			p.AddAlternate()
		case ruleAction27:
			p.AddRange()
		case ruleAction28:
			p.AddDoubleRange()
		case ruleAction29:
			p.AddCharacter(text)
		case ruleAction30:
			p.AddDoubleCharacter(text)
		case ruleAction31:
			p.AddCharacter(text)
		case ruleAction32:
			p.AddCharacter("\a")
		case ruleAction33:
			p.AddCharacter("\b")
		case ruleAction34:
			p.AddCharacter("\x1B")
		case ruleAction35:
			p.AddCharacter("\f")
		case ruleAction36:
			p.AddCharacter("\n")
		case ruleAction37:
			p.AddCharacter("\r")
		case ruleAction38:
			p.AddCharacter("\t")
		case ruleAction39:
			p.AddCharacter("\v")
		case ruleAction40:
			p.AddCharacter("'")
		case ruleAction41:
			p.AddCharacter("\"")
		case ruleAction42:
			p.AddCharacter("[")
		case ruleAction43:
			p.AddCharacter("]")
		case ruleAction44:
			p.AddCharacter("-")
		case ruleAction45:
			p.AddHexaCharacter(text)
		case ruleAction46:
			p.AddOctalCharacter(text)
		case ruleAction47:
			p.AddOctalCharacter(text)
		case ruleAction48:
			p.AddCharacter("\\")
		case ruleAction49:
			p.AddSpace(text)
		case ruleAction50:
			p.AddComment(text)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*Peg) error {
	return func(p *Peg) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*Peg) error {
	return func(p *Peg) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}

func DisableMemoize() func(*Peg) error {
	return func(p *Peg) error {
		p.disableMemoize = true
		return nil
	}
}

type memo struct {
	Matched bool
	Partial []token32
}

type memoKey struct {
	Rule     uint32
	Position uint32
}

func (p *Peg) Init(options ...func(*Peg) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
		memoization          map[memoKey]memo
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0
		memoization = make(map[memoKey]memo)
		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	memoize := func(rule uint32, begin uint32, tokenIndexStart uint32, matched bool) {
		if p.disableMemoize {
			return
		}
		key := memoKey{rule, begin}
		if !matched {
			memoization[key] = memo{Matched: false}
		} else {
			t := tree.tree[tokenIndexStart:tokenIndex]
			tokenCopy := make([]token32, len(t))
			copy(tokenCopy, t)
			memoization[key] = memo{Matched: true, Partial: tokenCopy}
		}
	}

	memoizedResult := func(m memo) bool {
		if !m.Matched {
			return false
		}
		tree.tree = append(tree.tree[:tokenIndex], m.Partial...)
		tokenIndex += uint32(len(m.Partial))
		position = m.Partial[len(m.Partial)-1].end
		if tree.tree[tokenIndex-1].begin != position && position > max.end {
			max = tree.tree[tokenIndex-1]
		}
		return true
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	_rules = [...]func() bool{
		nil,
		/* 0 Grammar <- <(Header ('p' 'a' 'c' 'k' 'a' 'g' 'e') MustSpacing Identifier Action0 Import* ('t' 'y' 'p' 'e') MustSpacing Identifier Action1 ('P' 'e' 'g') Spacing Action Action2 Definition+ EndOfFile)> */
		func() bool {
			if memoized, ok := memoization[memoKey{0, position}]; ok {
				return memoizedResult(memoized)
			}
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				{
					position2 := position
				l3:
					{
						position4, tokenIndex4 := position, tokenIndex
						{
							position5 := position
							{
								position6, tokenIndex6 := position, tokenIndex
								{
									position8 := position
									{
										position9, tokenIndex9 := position, tokenIndex
										if buffer[position] != '#' {
											goto l10
										}
										position++
										goto l9
									l10:
										position, tokenIndex = position9, tokenIndex9
										if buffer[position] != '/' {
											goto l7
										}
										position++
										if buffer[position] != '/' {
											goto l7
										}
										position++
									}
								l9:
									{
										position11 := position
									l12:
										{
											position13, tokenIndex13 := position, tokenIndex
											{
												position14, tokenIndex14 := position, tokenIndex
												if !_rules[ruleEndOfLine]() {
													goto l14
												}
												goto l13
											l14:
												position, tokenIndex = position14, tokenIndex14
											}
											if !matchDot() {
												goto l13
											}
											goto l12
										l13:
											position, tokenIndex = position13, tokenIndex13
										}
										add(rulePegText, position11)
									}
									{
										add(ruleAction50, position)
									}
									if !_rules[ruleEndOfLine]() {
										goto l7
									}
									add(ruleHeaderComment, position8)
								}
								goto l6
							l7:
								position, tokenIndex = position6, tokenIndex6
								{
									position16 := position
									if !_rules[ruleSpace]() {
										goto l4
									}
								l17:
									{
										position18, tokenIndex18 := position, tokenIndex
										if !_rules[ruleSpace]() {
											goto l18
										}
										goto l17
									l18:
										position, tokenIndex = position18, tokenIndex18
									}
									add(rulePegText, position16)
								}
								{
									add(ruleAction49, position)
								}
							}
						l6:
							add(ruleHeaderSpaceComment, position5)
						}
						goto l3
					l4:
						position, tokenIndex = position4, tokenIndex4
					}
					add(ruleHeader, position2)
				}
				if buffer[position] != 'p' {
					goto l0
				}
				position++
				if buffer[position] != 'a' {
					goto l0
				}
				position++
				if buffer[position] != 'c' {
					goto l0
				}
				position++
				if buffer[position] != 'k' {
					goto l0
				}
				position++
				if buffer[position] != 'a' {
					goto l0
				}
				position++
				if buffer[position] != 'g' {
					goto l0
				}
				position++
				if buffer[position] != 'e' {
					goto l0
				}
				position++
				if !_rules[ruleMustSpacing]() {
					goto l0
				}
				if !_rules[ruleIdentifier]() {
					goto l0
				}
				{
					add(ruleAction0, position)
				}
			l21:
				{
					position22, tokenIndex22 := position, tokenIndex
					{
						position23 := position
						if buffer[position] != 'i' {
							goto l22
						}
						position++
						if buffer[position] != 'm' {
							goto l22
						}
						position++
						if buffer[position] != 'p' {
							goto l22
						}
						position++
						if buffer[position] != 'o' {
							goto l22
						}
						position++
						if buffer[position] != 'r' {
							goto l22
						}
						position++
						if buffer[position] != 't' {
							goto l22
						}
						position++
						if !_rules[ruleSpacing]() {
							goto l22
						}
						{
							position24, tokenIndex24 := position, tokenIndex
							{
								position26 := position
								if buffer[position] != '(' {
									goto l25
								}
								position++
								if !_rules[ruleSpacing]() {
									goto l25
								}
							l27:
								{
									position28, tokenIndex28 := position, tokenIndex
									if !_rules[ruleImportName]() {
										goto l28
									}
									if buffer[position] != '\n' {
										goto l28
									}
									position++
									if !_rules[ruleSpacing]() {
										goto l28
									}
									goto l27
								l28:
									position, tokenIndex = position28, tokenIndex28
								}
								if !_rules[ruleSpacing]() {
									goto l25
								}
								if buffer[position] != ')' {
									goto l25
								}
								position++
								add(ruleMultiImport, position26)
							}
							goto l24
						l25:
							position, tokenIndex = position24, tokenIndex24
							{
								position29 := position
								if !_rules[ruleImportName]() {
									goto l22
								}
								add(ruleSingleImport, position29)
							}
						}
					l24:
						if !_rules[ruleSpacing]() {
							goto l22
						}
						add(ruleImport, position23)
					}
					goto l21
				l22:
					position, tokenIndex = position22, tokenIndex22
				}
				if buffer[position] != 't' {
					goto l0
				}
				position++
				if buffer[position] != 'y' {
					goto l0
				}
				position++
				if buffer[position] != 'p' {
					goto l0
				}
				position++
				if buffer[position] != 'e' {
					goto l0
				}
				position++
				if !_rules[ruleMustSpacing]() {
					goto l0
				}
				if !_rules[ruleIdentifier]() {
					goto l0
				}
				{
					add(ruleAction1, position)
				}
				if buffer[position] != 'P' {
					goto l0
				}
				position++
				if buffer[position] != 'e' {
					goto l0
				}
				position++
				if buffer[position] != 'g' {
					goto l0
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l0
				}
				if !_rules[ruleAction]() {
					goto l0
				}
				{
					add(ruleAction2, position)
				}
				{
					position34 := position
					if !_rules[ruleIdentifier]() {
						goto l0
					}
					{
						add(ruleAction4, position)
					}
					if !_rules[ruleLeftArrow]() {
						goto l0
					}
					if !_rules[ruleExpression]() {
						goto l0
					}
					{
						add(ruleAction5, position)
					}
					{
						position37, tokenIndex37 := position, tokenIndex
						{
							position38, tokenIndex38 := position, tokenIndex
							if !_rules[ruleIdentifier]() {
								goto l39
							}
							if !_rules[ruleLeftArrow]() {
								goto l39
							}
							goto l38
						l39:
							position, tokenIndex = position38, tokenIndex38
							{
								position40, tokenIndex40 := position, tokenIndex
								if !matchDot() {
									goto l40
								}
								goto l0
							l40:
								position, tokenIndex = position40, tokenIndex40
							}
						}
					l38:
						position, tokenIndex = position37, tokenIndex37
					}
					add(ruleDefinition, position34)
				}
			l32:
				{
					position33, tokenIndex33 := position, tokenIndex
					{
						position41 := position
						if !_rules[ruleIdentifier]() {
							goto l33
						}
						{
							add(ruleAction4, position)
						}
						if !_rules[ruleLeftArrow]() {
							goto l33
						}
						if !_rules[ruleExpression]() {
							goto l33
						}
						{
							add(ruleAction5, position)
						}
						{
							position44, tokenIndex44 := position, tokenIndex
							{
								position45, tokenIndex45 := position, tokenIndex
								if !_rules[ruleIdentifier]() {
									goto l46
								}
								if !_rules[ruleLeftArrow]() {
									goto l46
								}
								goto l45
							l46:
								position, tokenIndex = position45, tokenIndex45
								{
									position47, tokenIndex47 := position, tokenIndex
									if !matchDot() {
										goto l47
									}
									goto l33
								l47:
									position, tokenIndex = position47, tokenIndex47
								}
							}
						l45:
							position, tokenIndex = position44, tokenIndex44
						}
						add(ruleDefinition, position41)
					}
					goto l32
				l33:
					position, tokenIndex = position33, tokenIndex33
				}
				{
					position48 := position
					{
						position49, tokenIndex49 := position, tokenIndex
						if !matchDot() {
							goto l49
						}
						goto l0
					l49:
						position, tokenIndex = position49, tokenIndex49
					}
					add(ruleEndOfFile, position48)
				}
				add(ruleGrammar, position1)
			}
			memoize(0, position0, tokenIndex0, true)
			return true
		l0:
			memoize(0, position0, tokenIndex0, false)
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Import <- <('i' 'm' 'p' 'o' 'r' 't' Spacing (MultiImport / SingleImport) Spacing)> */
		nil,
		/* 2 SingleImport <- <ImportName> */
		nil,
		/* 3 MultiImport <- <('(' Spacing (ImportName '\n' Spacing)* Spacing ')')> */
		nil,
		/* 4 ImportName <- <('"' <((&('-') '-') | (&('.') '.') | (&('/') '/') | (&('_') '_') | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))+> '"' Action3)> */
		func() bool {
			if memoized, ok := memoization[memoKey{4, position}]; ok {
				return memoizedResult(memoized)
			}
			position53, tokenIndex53 := position, tokenIndex
			{
				position54 := position
				if buffer[position] != '"' {
					goto l53
				}
				position++
				{
					position55 := position
					{
						switch buffer[position] {
						case '-':
							position++
						case '.':
							position++
						case '/':
							position++
						case '_':
							position++
						case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
							position++
						case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
							position++
						default:
							if c := buffer[position]; c < 'a' || c > 'z' {
								goto l53
							}
							position++
						}
					}

				l56:
					{
						position57, tokenIndex57 := position, tokenIndex
						{
							switch buffer[position] {
							case '-':
								position++
							case '.':
								position++
							case '/':
								position++
							case '_':
								position++
							case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
								position++
							case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
								position++
							default:
								if c := buffer[position]; c < 'a' || c > 'z' {
									goto l57
								}
								position++
							}
						}

						goto l56
					l57:
						position, tokenIndex = position57, tokenIndex57
					}
					add(rulePegText, position55)
				}
				if buffer[position] != '"' {
					goto l53
				}
				position++
				{
					add(ruleAction3, position)
				}
				add(ruleImportName, position54)
			}
			memoize(4, position53, tokenIndex53, true)
			return true
		l53:
			memoize(4, position53, tokenIndex53, false)
			position, tokenIndex = position53, tokenIndex53
			return false
		},
		/* 5 Definition <- <(Identifier Action4 LeftArrow Expression Action5 &((Identifier LeftArrow) / !.))> */
		nil,
		/* 6 Expression <- <((Sequence (Slash Sequence Action6)* (Slash Action7)?) / Action8)> */
		func() bool {
			if memoized, ok := memoization[memoKey{6, position}]; ok {
				return memoizedResult(memoized)
			}
			position62, tokenIndex62 := position, tokenIndex
			{
				position63 := position
				{
					position64, tokenIndex64 := position, tokenIndex
					if !_rules[ruleSequence]() {
						goto l65
					}
				l66:
					{
						position67, tokenIndex67 := position, tokenIndex
						if !_rules[ruleSlash]() {
							goto l67
						}
						if !_rules[ruleSequence]() {
							goto l67
						}
						{
							add(ruleAction6, position)
						}
						goto l66
					l67:
						position, tokenIndex = position67, tokenIndex67
					}
					{
						position69, tokenIndex69 := position, tokenIndex
						if !_rules[ruleSlash]() {
							goto l69
						}
						{
							add(ruleAction7, position)
						}
						goto l70
					l69:
						position, tokenIndex = position69, tokenIndex69
					}
				l70:
					goto l64
				l65:
					position, tokenIndex = position64, tokenIndex64
					{
						add(ruleAction8, position)
					}
				}
			l64:
				add(ruleExpression, position63)
			}
			memoize(6, position62, tokenIndex62, true)
			return true
		},
		/* 7 Sequence <- <(Prefix (Prefix Action9)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{7, position}]; ok {
				return memoizedResult(memoized)
			}
			position73, tokenIndex73 := position, tokenIndex
			{
				position74 := position
				if !_rules[rulePrefix]() {
					goto l73
				}
			l75:
				{
					position76, tokenIndex76 := position, tokenIndex
					if !_rules[rulePrefix]() {
						goto l76
					}
					{
						add(ruleAction9, position)
					}
					goto l75
				l76:
					position, tokenIndex = position76, tokenIndex76
				}
				add(ruleSequence, position74)
			}
			memoize(7, position73, tokenIndex73, true)
			return true
		l73:
			memoize(7, position73, tokenIndex73, false)
			position, tokenIndex = position73, tokenIndex73
			return false
		},
		/* 8 Prefix <- <((And Action Action10) / (Not Action Action11) / ((&('!') (Not Suffix Action13)) | (&('&') (And Suffix Action12)) | (&('"' | '\'' | '(' | '.' | '<' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[' | '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{') Suffix)))> */
		func() bool {
			if memoized, ok := memoization[memoKey{8, position}]; ok {
				return memoizedResult(memoized)
			}
			position78, tokenIndex78 := position, tokenIndex
			{
				position79 := position
				{
					position80, tokenIndex80 := position, tokenIndex
					if !_rules[ruleAnd]() {
						goto l81
					}
					if !_rules[ruleAction]() {
						goto l81
					}
					{
						add(ruleAction10, position)
					}
					goto l80
				l81:
					position, tokenIndex = position80, tokenIndex80
					if !_rules[ruleNot]() {
						goto l83
					}
					if !_rules[ruleAction]() {
						goto l83
					}
					{
						add(ruleAction11, position)
					}
					goto l80
				l83:
					position, tokenIndex = position80, tokenIndex80
					{
						switch buffer[position] {
						case '!':
							if !_rules[ruleNot]() {
								goto l78
							}
							if !_rules[ruleSuffix]() {
								goto l78
							}
							{
								add(ruleAction13, position)
							}
						case '&':
							if !_rules[ruleAnd]() {
								goto l78
							}
							if !_rules[ruleSuffix]() {
								goto l78
							}
							{
								add(ruleAction12, position)
							}
						default:
							if !_rules[ruleSuffix]() {
								goto l78
							}
						}
					}

				}
			l80:
				add(rulePrefix, position79)
			}
			memoize(8, position78, tokenIndex78, true)
			return true
		l78:
			memoize(8, position78, tokenIndex78, false)
			position, tokenIndex = position78, tokenIndex78
			return false
		},
		/* 9 Suffix <- <(Primary ((&('+') (Plus Action16)) | (&('*') (Star Action15)) | (&('?') (Question Action14)))?)> */
		func() bool {
			if memoized, ok := memoization[memoKey{9, position}]; ok {
				return memoizedResult(memoized)
			}
			position88, tokenIndex88 := position, tokenIndex
			{
				position89 := position
				{
					position90 := position
					{
						switch buffer[position] {
						case '<':
							{
								position92 := position
								position++
								if !_rules[ruleSpacing]() {
									goto l88
								}
								add(ruleBegin, position92)
							}
							if !_rules[ruleExpression]() {
								goto l88
							}
							{
								position93 := position
								if buffer[position] != '>' {
									goto l88
								}
								position++
								if !_rules[ruleSpacing]() {
									goto l88
								}
								add(ruleEnd, position93)
							}
							{
								add(ruleAction20, position)
							}
						case '{':
							if !_rules[ruleAction]() {
								goto l88
							}
							{
								add(ruleAction19, position)
							}
						case '.':
							{
								position96 := position
								position++
								if !_rules[ruleSpacing]() {
									goto l88
								}
								add(ruleDot, position96)
							}
							{
								add(ruleAction18, position)
							}
						case '[':
							{
								position98 := position
								{
									position99, tokenIndex99 := position, tokenIndex
									position++
									if buffer[position] != '[' {
										goto l100
									}
									position++
									{
										position101, tokenIndex101 := position, tokenIndex
										{
											position103, tokenIndex103 := position, tokenIndex
											if buffer[position] != '^' {
												goto l104
											}
											position++
											if !_rules[ruleDoubleRanges]() {
												goto l104
											}
											{
												add(ruleAction23, position)
											}
											goto l103
										l104:
											position, tokenIndex = position103, tokenIndex103
											if !_rules[ruleDoubleRanges]() {
												goto l101
											}
										}
									l103:
										goto l102
									l101:
										position, tokenIndex = position101, tokenIndex101
									}
								l102:
									if buffer[position] != ']' {
										goto l100
									}
									position++
									if buffer[position] != ']' {
										goto l100
									}
									position++
									goto l99
								l100:
									position, tokenIndex = position99, tokenIndex99
									if buffer[position] != '[' {
										goto l88
									}
									position++
									{
										position106, tokenIndex106 := position, tokenIndex
										{
											position108, tokenIndex108 := position, tokenIndex
											if buffer[position] != '^' {
												goto l109
											}
											position++
											if !_rules[ruleRanges]() {
												goto l109
											}
											{
												add(ruleAction24, position)
											}
											goto l108
										l109:
											position, tokenIndex = position108, tokenIndex108
											if !_rules[ruleRanges]() {
												goto l106
											}
										}
									l108:
										goto l107
									l106:
										position, tokenIndex = position106, tokenIndex106
									}
								l107:
									if buffer[position] != ']' {
										goto l88
									}
									position++
								}
							l99:
								if !_rules[ruleSpacing]() {
									goto l88
								}
								add(ruleClass, position98)
							}
						case '"', '\'':
							{
								position111 := position
								{
									position112, tokenIndex112 := position, tokenIndex
									if buffer[position] != '\'' {
										goto l113
									}
									position++
									{
										position114, tokenIndex114 := position, tokenIndex
										{
											position116, tokenIndex116 := position, tokenIndex
											if buffer[position] != '\'' {
												goto l116
											}
											position++
											goto l114
										l116:
											position, tokenIndex = position116, tokenIndex116
										}
										if !_rules[ruleChar]() {
											goto l114
										}
										goto l115
									l114:
										position, tokenIndex = position114, tokenIndex114
									}
								l115:
								l117:
									{
										position118, tokenIndex118 := position, tokenIndex
										{
											position119, tokenIndex119 := position, tokenIndex
											if buffer[position] != '\'' {
												goto l119
											}
											position++
											goto l118
										l119:
											position, tokenIndex = position119, tokenIndex119
										}
										if !_rules[ruleChar]() {
											goto l118
										}
										{
											add(ruleAction21, position)
										}
										goto l117
									l118:
										position, tokenIndex = position118, tokenIndex118
									}
									if buffer[position] != '\'' {
										goto l113
									}
									position++
									if !_rules[ruleSpacing]() {
										goto l113
									}
									goto l112
								l113:
									position, tokenIndex = position112, tokenIndex112
									if buffer[position] != '"' {
										goto l88
									}
									position++
									{
										position121, tokenIndex121 := position, tokenIndex
										{
											position123, tokenIndex123 := position, tokenIndex
											if buffer[position] != '"' {
												goto l123
											}
											position++
											goto l121
										l123:
											position, tokenIndex = position123, tokenIndex123
										}
										if !_rules[ruleDoubleChar]() {
											goto l121
										}
										goto l122
									l121:
										position, tokenIndex = position121, tokenIndex121
									}
								l122:
								l124:
									{
										position125, tokenIndex125 := position, tokenIndex
										{
											position126, tokenIndex126 := position, tokenIndex
											if buffer[position] != '"' {
												goto l126
											}
											position++
											goto l125
										l126:
											position, tokenIndex = position126, tokenIndex126
										}
										if !_rules[ruleDoubleChar]() {
											goto l125
										}
										{
											add(ruleAction22, position)
										}
										goto l124
									l125:
										position, tokenIndex = position125, tokenIndex125
									}
									if buffer[position] != '"' {
										goto l88
									}
									position++
									if !_rules[ruleSpacing]() {
										goto l88
									}
								}
							l112:
								add(ruleLiteral, position111)
							}
						case '(':
							{
								position128 := position
								position++
								if !_rules[ruleSpacing]() {
									goto l88
								}
								add(ruleOpen, position128)
							}
							if !_rules[ruleExpression]() {
								goto l88
							}
							{
								position129 := position
								if buffer[position] != ')' {
									goto l88
								}
								position++
								if !_rules[ruleSpacing]() {
									goto l88
								}
								add(ruleClose, position129)
							}
						default:
							if !_rules[ruleIdentifier]() {
								goto l88
							}
							{
								position130, tokenIndex130 := position, tokenIndex
								if !_rules[ruleLeftArrow]() {
									goto l130
								}
								goto l88
							l130:
								position, tokenIndex = position130, tokenIndex130
							}
							{
								add(ruleAction17, position)
							}
						}
					}

					add(rulePrimary, position90)
				}
				{
					position132, tokenIndex132 := position, tokenIndex
					{
						switch buffer[position] {
						case '+':
							{
								position135 := position
								position++
								if !_rules[ruleSpacing]() {
									goto l132
								}
								add(rulePlus, position135)
							}
							{
								add(ruleAction16, position)
							}
						case '*':
							{
								position137 := position
								position++
								if !_rules[ruleSpacing]() {
									goto l132
								}
								add(ruleStar, position137)
							}
							{
								add(ruleAction15, position)
							}
						default:
							{
								position139 := position
								if buffer[position] != '?' {
									goto l132
								}
								position++
								if !_rules[ruleSpacing]() {
									goto l132
								}
								add(ruleQuestion, position139)
							}
							{
								add(ruleAction14, position)
							}
						}
					}

					goto l133
				l132:
					position, tokenIndex = position132, tokenIndex132
				}
			l133:
				add(ruleSuffix, position89)
			}
			memoize(9, position88, tokenIndex88, true)
			return true
		l88:
			memoize(9, position88, tokenIndex88, false)
			position, tokenIndex = position88, tokenIndex88
			return false
		},
		/* 10 Primary <- <((&('<') (Begin Expression End Action20)) | (&('{') (Action Action19)) | (&('.') (Dot Action18)) | (&('[') Class) | (&('"' | '\'') Literal) | (&('(') (Open Expression Close)) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '_' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') (Identifier !LeftArrow Action17)))> */
		nil,
		/* 11 Identifier <- <(<(IdentStart IdentCont*)> Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{11, position}]; ok {
				return memoizedResult(memoized)
			}
			position142, tokenIndex142 := position, tokenIndex
			{
				position143 := position
				{
					position144 := position
					if !_rules[ruleIdentStart]() {
						goto l142
					}
				l145:
					{
						position146, tokenIndex146 := position, tokenIndex
						{
							position147 := position
							{
								position148, tokenIndex148 := position, tokenIndex
								if !_rules[ruleIdentStart]() {
									goto l149
								}
								goto l148
							l149:
								position, tokenIndex = position148, tokenIndex148
								if c := buffer[position]; c < '0' || c > '9' {
									goto l146
								}
								position++
							}
						l148:
							add(ruleIdentCont, position147)
						}
						goto l145
					l146:
						position, tokenIndex = position146, tokenIndex146
					}
					add(rulePegText, position144)
				}
				if !_rules[ruleSpacing]() {
					goto l142
				}
				add(ruleIdentifier, position143)
			}
			memoize(11, position142, tokenIndex142, true)
			return true
		l142:
			memoize(11, position142, tokenIndex142, false)
			position, tokenIndex = position142, tokenIndex142
			return false
		},
		/* 12 IdentStart <- <((&('_') '_') | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]))> */
		func() bool {
			if memoized, ok := memoization[memoKey{12, position}]; ok {
				return memoizedResult(memoized)
			}
			position150, tokenIndex150 := position, tokenIndex
			{
				position151 := position
				{
					switch buffer[position] {
					case '_':
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z':
						position++
					default:
						if c := buffer[position]; c < 'a' || c > 'z' {
							goto l150
						}
						position++
					}
				}

				add(ruleIdentStart, position151)
			}
			memoize(12, position150, tokenIndex150, true)
			return true
		l150:
			memoize(12, position150, tokenIndex150, false)
			position, tokenIndex = position150, tokenIndex150
			return false
		},
		/* 13 IdentCont <- <(IdentStart / [0-9])> */
		nil,
		/* 14 Literal <- <(('\'' (!'\'' Char)? (!'\'' Char Action21)* '\'' Spacing) / ('"' (!'"' DoubleChar)? (!'"' DoubleChar Action22)* '"' Spacing))> */
		nil,
		/* 15 Class <- <((('[' '[' (('^' DoubleRanges Action23) / DoubleRanges)? (']' ']')) / ('[' (('^' Ranges Action24) / Ranges)? ']')) Spacing)> */
		nil,
		/* 16 Ranges <- <(!']' Range (!']' Range Action25)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{16, position}]; ok {
				return memoizedResult(memoized)
			}
			position156, tokenIndex156 := position, tokenIndex
			{
				position157 := position
				{
					position158, tokenIndex158 := position, tokenIndex
					if buffer[position] != ']' {
						goto l158
					}
					position++
					goto l156
				l158:
					position, tokenIndex = position158, tokenIndex158
				}
				if !_rules[ruleRange]() {
					goto l156
				}
			l159:
				{
					position160, tokenIndex160 := position, tokenIndex
					{
						position161, tokenIndex161 := position, tokenIndex
						if buffer[position] != ']' {
							goto l161
						}
						position++
						goto l160
					l161:
						position, tokenIndex = position161, tokenIndex161
					}
					if !_rules[ruleRange]() {
						goto l160
					}
					{
						add(ruleAction25, position)
					}
					goto l159
				l160:
					position, tokenIndex = position160, tokenIndex160
				}
				add(ruleRanges, position157)
			}
			memoize(16, position156, tokenIndex156, true)
			return true
		l156:
			memoize(16, position156, tokenIndex156, false)
			position, tokenIndex = position156, tokenIndex156
			return false
		},
		/* 17 DoubleRanges <- <(!(']' ']') DoubleRange (!(']' ']') DoubleRange Action26)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{17, position}]; ok {
				return memoizedResult(memoized)
			}
			position163, tokenIndex163 := position, tokenIndex
			{
				position164 := position
				{
					position165, tokenIndex165 := position, tokenIndex
					if buffer[position] != ']' {
						goto l165
					}
					position++
					if buffer[position] != ']' {
						goto l165
					}
					position++
					goto l163
				l165:
					position, tokenIndex = position165, tokenIndex165
				}
				if !_rules[ruleDoubleRange]() {
					goto l163
				}
			l166:
				{
					position167, tokenIndex167 := position, tokenIndex
					{
						position168, tokenIndex168 := position, tokenIndex
						if buffer[position] != ']' {
							goto l168
						}
						position++
						if buffer[position] != ']' {
							goto l168
						}
						position++
						goto l167
					l168:
						position, tokenIndex = position168, tokenIndex168
					}
					if !_rules[ruleDoubleRange]() {
						goto l167
					}
					{
						add(ruleAction26, position)
					}
					goto l166
				l167:
					position, tokenIndex = position167, tokenIndex167
				}
				add(ruleDoubleRanges, position164)
			}
			memoize(17, position163, tokenIndex163, true)
			return true
		l163:
			memoize(17, position163, tokenIndex163, false)
			position, tokenIndex = position163, tokenIndex163
			return false
		},
		/* 18 Range <- <((Char '-' Char Action27) / Char)> */
		func() bool {
			if memoized, ok := memoization[memoKey{18, position}]; ok {
				return memoizedResult(memoized)
			}
			position170, tokenIndex170 := position, tokenIndex
			{
				position171 := position
				{
					position172, tokenIndex172 := position, tokenIndex
					if !_rules[ruleChar]() {
						goto l173
					}
					if buffer[position] != '-' {
						goto l173
					}
					position++
					if !_rules[ruleChar]() {
						goto l173
					}
					{
						add(ruleAction27, position)
					}
					goto l172
				l173:
					position, tokenIndex = position172, tokenIndex172
					if !_rules[ruleChar]() {
						goto l170
					}
				}
			l172:
				add(ruleRange, position171)
			}
			memoize(18, position170, tokenIndex170, true)
			return true
		l170:
			memoize(18, position170, tokenIndex170, false)
			position, tokenIndex = position170, tokenIndex170
			return false
		},
		/* 19 DoubleRange <- <((Char '-' Char Action28) / DoubleChar)> */
		func() bool {
			if memoized, ok := memoization[memoKey{19, position}]; ok {
				return memoizedResult(memoized)
			}
			position175, tokenIndex175 := position, tokenIndex
			{
				position176 := position
				{
					position177, tokenIndex177 := position, tokenIndex
					if !_rules[ruleChar]() {
						goto l178
					}
					if buffer[position] != '-' {
						goto l178
					}
					position++
					if !_rules[ruleChar]() {
						goto l178
					}
					{
						add(ruleAction28, position)
					}
					goto l177
				l178:
					position, tokenIndex = position177, tokenIndex177
					if !_rules[ruleDoubleChar]() {
						goto l175
					}
				}
			l177:
				add(ruleDoubleRange, position176)
			}
			memoize(19, position175, tokenIndex175, true)
			return true
		l175:
			memoize(19, position175, tokenIndex175, false)
			position, tokenIndex = position175, tokenIndex175
			return false
		},
		/* 20 Char <- <(Escape / (!'\\' <.> Action29))> */
		func() bool {
			if memoized, ok := memoization[memoKey{20, position}]; ok {
				return memoizedResult(memoized)
			}
			position180, tokenIndex180 := position, tokenIndex
			{
				position181 := position
				{
					position182, tokenIndex182 := position, tokenIndex
					if !_rules[ruleEscape]() {
						goto l183
					}
					goto l182
				l183:
					position, tokenIndex = position182, tokenIndex182
					{
						position184, tokenIndex184 := position, tokenIndex
						if buffer[position] != '\\' {
							goto l184
						}
						position++
						goto l180
					l184:
						position, tokenIndex = position184, tokenIndex184
					}
					{
						position185 := position
						if !matchDot() {
							goto l180
						}
						add(rulePegText, position185)
					}
					{
						add(ruleAction29, position)
					}
				}
			l182:
				add(ruleChar, position181)
			}
			memoize(20, position180, tokenIndex180, true)
			return true
		l180:
			memoize(20, position180, tokenIndex180, false)
			position, tokenIndex = position180, tokenIndex180
			return false
		},
		/* 21 DoubleChar <- <(Escape / (<([a-z] / [A-Z])> Action30) / (!'\\' <.> Action31))> */
		func() bool {
			if memoized, ok := memoization[memoKey{21, position}]; ok {
				return memoizedResult(memoized)
			}
			position187, tokenIndex187 := position, tokenIndex
			{
				position188 := position
				{
					position189, tokenIndex189 := position, tokenIndex
					if !_rules[ruleEscape]() {
						goto l190
					}
					goto l189
				l190:
					position, tokenIndex = position189, tokenIndex189
					{
						position192 := position
						{
							position193, tokenIndex193 := position, tokenIndex
							if c := buffer[position]; c < 'a' || c > 'z' {
								goto l194
							}
							position++
							goto l193
						l194:
							position, tokenIndex = position193, tokenIndex193
							if c := buffer[position]; c < 'A' || c > 'Z' {
								goto l191
							}
							position++
						}
					l193:
						add(rulePegText, position192)
					}
					{
						add(ruleAction30, position)
					}
					goto l189
				l191:
					position, tokenIndex = position189, tokenIndex189
					{
						position196, tokenIndex196 := position, tokenIndex
						if buffer[position] != '\\' {
							goto l196
						}
						position++
						goto l187
					l196:
						position, tokenIndex = position196, tokenIndex196
					}
					{
						position197 := position
						if !matchDot() {
							goto l187
						}
						add(rulePegText, position197)
					}
					{
						add(ruleAction31, position)
					}
				}
			l189:
				add(ruleDoubleChar, position188)
			}
			memoize(21, position187, tokenIndex187, true)
			return true
		l187:
			memoize(21, position187, tokenIndex187, false)
			position, tokenIndex = position187, tokenIndex187
			return false
		},
		/* 22 Escape <- <(('\\' ('a' / 'A') Action32) / ('\\' ('b' / 'B') Action33) / ('\\' ('e' / 'E') Action34) / ('\\' ('f' / 'F') Action35) / ('\\' ('n' / 'N') Action36) / ('\\' ('r' / 'R') Action37) / ('\\' ('t' / 'T') Action38) / ('\\' ('v' / 'V') Action39) / ('\\' '\'' Action40) / ('\\' '"' Action41) / ('\\' '[' Action42) / ('\\' ']' Action43) / ('\\' '-' Action44) / ('\\' ('0' ('x' / 'X')) <((&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))+> Action45) / ('\\' <([0-3] [0-7] [0-7])> Action46) / ('\\' <([0-7] [0-7]?)> Action47) / ('\\' '\\' Action48))> */
		func() bool {
			if memoized, ok := memoization[memoKey{22, position}]; ok {
				return memoizedResult(memoized)
			}
			position199, tokenIndex199 := position, tokenIndex
			{
				position200 := position
				{
					position201, tokenIndex201 := position, tokenIndex
					if buffer[position] != '\\' {
						goto l202
					}
					position++
					{
						position203, tokenIndex203 := position, tokenIndex
						if buffer[position] != 'a' {
							goto l204
						}
						position++
						goto l203
					l204:
						position, tokenIndex = position203, tokenIndex203
						if buffer[position] != 'A' {
							goto l202
						}
						position++
					}
				l203:
					{
						add(ruleAction32, position)
					}
					goto l201
				l202:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l206
					}
					position++
					{
						position207, tokenIndex207 := position, tokenIndex
						if buffer[position] != 'b' {
							goto l208
						}
						position++
						goto l207
					l208:
						position, tokenIndex = position207, tokenIndex207
						if buffer[position] != 'B' {
							goto l206
						}
						position++
					}
				l207:
					{
						add(ruleAction33, position)
					}
					goto l201
				l206:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l210
					}
					position++
					{
						position211, tokenIndex211 := position, tokenIndex
						if buffer[position] != 'e' {
							goto l212
						}
						position++
						goto l211
					l212:
						position, tokenIndex = position211, tokenIndex211
						if buffer[position] != 'E' {
							goto l210
						}
						position++
					}
				l211:
					{
						add(ruleAction34, position)
					}
					goto l201
				l210:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l214
					}
					position++
					{
						position215, tokenIndex215 := position, tokenIndex
						if buffer[position] != 'f' {
							goto l216
						}
						position++
						goto l215
					l216:
						position, tokenIndex = position215, tokenIndex215
						if buffer[position] != 'F' {
							goto l214
						}
						position++
					}
				l215:
					{
						add(ruleAction35, position)
					}
					goto l201
				l214:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l218
					}
					position++
					{
						position219, tokenIndex219 := position, tokenIndex
						if buffer[position] != 'n' {
							goto l220
						}
						position++
						goto l219
					l220:
						position, tokenIndex = position219, tokenIndex219
						if buffer[position] != 'N' {
							goto l218
						}
						position++
					}
				l219:
					{
						add(ruleAction36, position)
					}
					goto l201
				l218:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l222
					}
					position++
					{
						position223, tokenIndex223 := position, tokenIndex
						if buffer[position] != 'r' {
							goto l224
						}
						position++
						goto l223
					l224:
						position, tokenIndex = position223, tokenIndex223
						if buffer[position] != 'R' {
							goto l222
						}
						position++
					}
				l223:
					{
						add(ruleAction37, position)
					}
					goto l201
				l222:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l226
					}
					position++
					{
						position227, tokenIndex227 := position, tokenIndex
						if buffer[position] != 't' {
							goto l228
						}
						position++
						goto l227
					l228:
						position, tokenIndex = position227, tokenIndex227
						if buffer[position] != 'T' {
							goto l226
						}
						position++
					}
				l227:
					{
						add(ruleAction38, position)
					}
					goto l201
				l226:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l230
					}
					position++
					{
						position231, tokenIndex231 := position, tokenIndex
						if buffer[position] != 'v' {
							goto l232
						}
						position++
						goto l231
					l232:
						position, tokenIndex = position231, tokenIndex231
						if buffer[position] != 'V' {
							goto l230
						}
						position++
					}
				l231:
					{
						add(ruleAction39, position)
					}
					goto l201
				l230:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l234
					}
					position++
					if buffer[position] != '\'' {
						goto l234
					}
					position++
					{
						add(ruleAction40, position)
					}
					goto l201
				l234:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l236
					}
					position++
					if buffer[position] != '"' {
						goto l236
					}
					position++
					{
						add(ruleAction41, position)
					}
					goto l201
				l236:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l238
					}
					position++
					if buffer[position] != '[' {
						goto l238
					}
					position++
					{
						add(ruleAction42, position)
					}
					goto l201
				l238:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l240
					}
					position++
					if buffer[position] != ']' {
						goto l240
					}
					position++
					{
						add(ruleAction43, position)
					}
					goto l201
				l240:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l242
					}
					position++
					if buffer[position] != '-' {
						goto l242
					}
					position++
					{
						add(ruleAction44, position)
					}
					goto l201
				l242:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l244
					}
					position++
					if buffer[position] != '0' {
						goto l244
					}
					position++
					{
						position245, tokenIndex245 := position, tokenIndex
						if buffer[position] != 'x' {
							goto l246
						}
						position++
						goto l245
					l246:
						position, tokenIndex = position245, tokenIndex245
						if buffer[position] != 'X' {
							goto l244
						}
						position++
					}
				l245:
					{
						position247 := position
						{
							switch buffer[position] {
							case 'A', 'B', 'C', 'D', 'E', 'F':
								position++
							case 'a', 'b', 'c', 'd', 'e', 'f':
								position++
							default:
								if c := buffer[position]; c < '0' || c > '9' {
									goto l244
								}
								position++
							}
						}

					l248:
						{
							position249, tokenIndex249 := position, tokenIndex
							{
								switch buffer[position] {
								case 'A', 'B', 'C', 'D', 'E', 'F':
									position++
								case 'a', 'b', 'c', 'd', 'e', 'f':
									position++
								default:
									if c := buffer[position]; c < '0' || c > '9' {
										goto l249
									}
									position++
								}
							}

							goto l248
						l249:
							position, tokenIndex = position249, tokenIndex249
						}
						add(rulePegText, position247)
					}
					{
						add(ruleAction45, position)
					}
					goto l201
				l244:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l253
					}
					position++
					{
						position254 := position
						if c := buffer[position]; c < '0' || c > '3' {
							goto l253
						}
						position++
						if c := buffer[position]; c < '0' || c > '7' {
							goto l253
						}
						position++
						if c := buffer[position]; c < '0' || c > '7' {
							goto l253
						}
						position++
						add(rulePegText, position254)
					}
					{
						add(ruleAction46, position)
					}
					goto l201
				l253:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l256
					}
					position++
					{
						position257 := position
						if c := buffer[position]; c < '0' || c > '7' {
							goto l256
						}
						position++
						{
							position258, tokenIndex258 := position, tokenIndex
							if c := buffer[position]; c < '0' || c > '7' {
								goto l258
							}
							position++
							goto l259
						l258:
							position, tokenIndex = position258, tokenIndex258
						}
					l259:
						add(rulePegText, position257)
					}
					{
						add(ruleAction47, position)
					}
					goto l201
				l256:
					position, tokenIndex = position201, tokenIndex201
					if buffer[position] != '\\' {
						goto l199
					}
					position++
					if buffer[position] != '\\' {
						goto l199
					}
					position++
					{
						add(ruleAction48, position)
					}
				}
			l201:
				add(ruleEscape, position200)
			}
			memoize(22, position199, tokenIndex199, true)
			return true
		l199:
			memoize(22, position199, tokenIndex199, false)
			position, tokenIndex = position199, tokenIndex199
			return false
		},
		/* 23 LeftArrow <- <((('<' '-') / '←') Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{23, position}]; ok {
				return memoizedResult(memoized)
			}
			position262, tokenIndex262 := position, tokenIndex
			{
				position263 := position
				{
					position264, tokenIndex264 := position, tokenIndex
					if buffer[position] != '<' {
						goto l265
					}
					position++
					if buffer[position] != '-' {
						goto l265
					}
					position++
					goto l264
				l265:
					position, tokenIndex = position264, tokenIndex264
					if buffer[position] != '←' {
						goto l262
					}
					position++
				}
			l264:
				if !_rules[ruleSpacing]() {
					goto l262
				}
				add(ruleLeftArrow, position263)
			}
			memoize(23, position262, tokenIndex262, true)
			return true
		l262:
			memoize(23, position262, tokenIndex262, false)
			position, tokenIndex = position262, tokenIndex262
			return false
		},
		/* 24 Slash <- <('/' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{24, position}]; ok {
				return memoizedResult(memoized)
			}
			position266, tokenIndex266 := position, tokenIndex
			{
				position267 := position
				if buffer[position] != '/' {
					goto l266
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l266
				}
				add(ruleSlash, position267)
			}
			memoize(24, position266, tokenIndex266, true)
			return true
		l266:
			memoize(24, position266, tokenIndex266, false)
			position, tokenIndex = position266, tokenIndex266
			return false
		},
		/* 25 And <- <('&' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{25, position}]; ok {
				return memoizedResult(memoized)
			}
			position268, tokenIndex268 := position, tokenIndex
			{
				position269 := position
				if buffer[position] != '&' {
					goto l268
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l268
				}
				add(ruleAnd, position269)
			}
			memoize(25, position268, tokenIndex268, true)
			return true
		l268:
			memoize(25, position268, tokenIndex268, false)
			position, tokenIndex = position268, tokenIndex268
			return false
		},
		/* 26 Not <- <('!' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{26, position}]; ok {
				return memoizedResult(memoized)
			}
			position270, tokenIndex270 := position, tokenIndex
			{
				position271 := position
				if buffer[position] != '!' {
					goto l270
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l270
				}
				add(ruleNot, position271)
			}
			memoize(26, position270, tokenIndex270, true)
			return true
		l270:
			memoize(26, position270, tokenIndex270, false)
			position, tokenIndex = position270, tokenIndex270
			return false
		},
		/* 27 Question <- <('?' Spacing)> */
		nil,
		/* 28 Star <- <('*' Spacing)> */
		nil,
		/* 29 Plus <- <('+' Spacing)> */
		nil,
		/* 30 Open <- <('(' Spacing)> */
		nil,
		/* 31 Close <- <(')' Spacing)> */
		nil,
		/* 32 Dot <- <('.' Spacing)> */
		nil,
		/* 33 SpaceComment <- <(Space / Comment)> */
		func() bool {
			if memoized, ok := memoization[memoKey{33, position}]; ok {
				return memoizedResult(memoized)
			}
			position278, tokenIndex278 := position, tokenIndex
			{
				position279 := position
				{
					position280, tokenIndex280 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l281
					}
					goto l280
				l281:
					position, tokenIndex = position280, tokenIndex280
					{
						position282 := position
						{
							position283, tokenIndex283 := position, tokenIndex
							if buffer[position] != '#' {
								goto l284
							}
							position++
							goto l283
						l284:
							position, tokenIndex = position283, tokenIndex283
							if buffer[position] != '/' {
								goto l278
							}
							position++
							if buffer[position] != '/' {
								goto l278
							}
							position++
						}
					l283:
					l285:
						{
							position286, tokenIndex286 := position, tokenIndex
							{
								position287, tokenIndex287 := position, tokenIndex
								if !_rules[ruleEndOfLine]() {
									goto l287
								}
								goto l286
							l287:
								position, tokenIndex = position287, tokenIndex287
							}
							if !matchDot() {
								goto l286
							}
							goto l285
						l286:
							position, tokenIndex = position286, tokenIndex286
						}
						if !_rules[ruleEndOfLine]() {
							goto l278
						}
						add(ruleComment, position282)
					}
				}
			l280:
				add(ruleSpaceComment, position279)
			}
			memoize(33, position278, tokenIndex278, true)
			return true
		l278:
			memoize(33, position278, tokenIndex278, false)
			position, tokenIndex = position278, tokenIndex278
			return false
		},
		/* 34 Spacing <- <SpaceComment*> */
		func() bool {
			if memoized, ok := memoization[memoKey{34, position}]; ok {
				return memoizedResult(memoized)
			}
			position288, tokenIndex288 := position, tokenIndex
			{
				position289 := position
			l290:
				{
					position291, tokenIndex291 := position, tokenIndex
					if !_rules[ruleSpaceComment]() {
						goto l291
					}
					goto l290
				l291:
					position, tokenIndex = position291, tokenIndex291
				}
				add(ruleSpacing, position289)
			}
			memoize(34, position288, tokenIndex288, true)
			return true
		},
		/* 35 MustSpacing <- <SpaceComment+> */
		func() bool {
			if memoized, ok := memoization[memoKey{35, position}]; ok {
				return memoizedResult(memoized)
			}
			position292, tokenIndex292 := position, tokenIndex
			{
				position293 := position
				if !_rules[ruleSpaceComment]() {
					goto l292
				}
			l294:
				{
					position295, tokenIndex295 := position, tokenIndex
					if !_rules[ruleSpaceComment]() {
						goto l295
					}
					goto l294
				l295:
					position, tokenIndex = position295, tokenIndex295
				}
				add(ruleMustSpacing, position293)
			}
			memoize(35, position292, tokenIndex292, true)
			return true
		l292:
			memoize(35, position292, tokenIndex292, false)
			position, tokenIndex = position292, tokenIndex292
			return false
		},
		/* 36 Comment <- <(('#' / ('/' '/')) (!EndOfLine .)* EndOfLine)> */
		nil,
		/* 37 Space <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') EndOfLine))> */
		func() bool {
			if memoized, ok := memoization[memoKey{37, position}]; ok {
				return memoizedResult(memoized)
			}
			position297, tokenIndex297 := position, tokenIndex
			{
				position298 := position
				{
					switch buffer[position] {
					case '\t':
						position++
					case ' ':
						position++
					default:
						if !_rules[ruleEndOfLine]() {
							goto l297
						}
					}
				}

				add(ruleSpace, position298)
			}
			memoize(37, position297, tokenIndex297, true)
			return true
		l297:
			memoize(37, position297, tokenIndex297, false)
			position, tokenIndex = position297, tokenIndex297
			return false
		},
		/* 38 Header <- <HeaderSpaceComment*> */
		nil,
		/* 39 HeaderSpaceComment <- <(HeaderComment / (<Space+> Action49))> */
		nil,
		/* 40 HeaderComment <- <(('#' / ('/' '/')) <(!EndOfLine .)*> Action50 EndOfLine)> */
		nil,
		/* 41 EndOfLine <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			if memoized, ok := memoization[memoKey{41, position}]; ok {
				return memoizedResult(memoized)
			}
			position303, tokenIndex303 := position, tokenIndex
			{
				position304 := position
				{
					position305, tokenIndex305 := position, tokenIndex
					if buffer[position] != '\r' {
						goto l306
					}
					position++
					if buffer[position] != '\n' {
						goto l306
					}
					position++
					goto l305
				l306:
					position, tokenIndex = position305, tokenIndex305
					if buffer[position] != '\n' {
						goto l307
					}
					position++
					goto l305
				l307:
					position, tokenIndex = position305, tokenIndex305
					if buffer[position] != '\r' {
						goto l303
					}
					position++
				}
			l305:
				add(ruleEndOfLine, position304)
			}
			memoize(41, position303, tokenIndex303, true)
			return true
		l303:
			memoize(41, position303, tokenIndex303, false)
			position, tokenIndex = position303, tokenIndex303
			return false
		},
		/* 42 EndOfFile <- <!.> */
		nil,
		/* 43 Action <- <('{' <ActionBody*> '}' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{43, position}]; ok {
				return memoizedResult(memoized)
			}
			position309, tokenIndex309 := position, tokenIndex
			{
				position310 := position
				if buffer[position] != '{' {
					goto l309
				}
				position++
				{
					position311 := position
				l312:
					{
						position313, tokenIndex313 := position, tokenIndex
						if !_rules[ruleActionBody]() {
							goto l313
						}
						goto l312
					l313:
						position, tokenIndex = position313, tokenIndex313
					}
					add(rulePegText, position311)
				}
				if buffer[position] != '}' {
					goto l309
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l309
				}
				add(ruleAction, position310)
			}
			memoize(43, position309, tokenIndex309, true)
			return true
		l309:
			memoize(43, position309, tokenIndex309, false)
			position, tokenIndex = position309, tokenIndex309
			return false
		},
		/* 44 ActionBody <- <((!('{' / '}') .) / ('{' ActionBody* '}'))> */
		func() bool {
			if memoized, ok := memoization[memoKey{44, position}]; ok {
				return memoizedResult(memoized)
			}
			position314, tokenIndex314 := position, tokenIndex
			{
				position315 := position
				{
					position316, tokenIndex316 := position, tokenIndex
					{
						position318, tokenIndex318 := position, tokenIndex
						{
							position319, tokenIndex319 := position, tokenIndex
							if buffer[position] != '{' {
								goto l320
							}
							position++
							goto l319
						l320:
							position, tokenIndex = position319, tokenIndex319
							if buffer[position] != '}' {
								goto l318
							}
							position++
						}
					l319:
						goto l317
					l318:
						position, tokenIndex = position318, tokenIndex318
					}
					if !matchDot() {
						goto l317
					}
					goto l316
				l317:
					position, tokenIndex = position316, tokenIndex316
					if buffer[position] != '{' {
						goto l314
					}
					position++
				l321:
					{
						position322, tokenIndex322 := position, tokenIndex
						if !_rules[ruleActionBody]() {
							goto l322
						}
						goto l321
					l322:
						position, tokenIndex = position322, tokenIndex322
					}
					if buffer[position] != '}' {
						goto l314
					}
					position++
				}
			l316:
				add(ruleActionBody, position315)
			}
			memoize(44, position314, tokenIndex314, true)
			return true
		l314:
			memoize(44, position314, tokenIndex314, false)
			position, tokenIndex = position314, tokenIndex314
			return false
		},
		/* 45 Begin <- <('<' Spacing)> */
		nil,
		/* 46 End <- <('>' Spacing)> */
		nil,
		/* 48 Action0 <- <{ p.AddPackage(text) }> */
		nil,
		/* 49 Action1 <- <{ p.AddPeg(text) }> */
		nil,
		/* 50 Action2 <- <{ p.AddState(text) }> */
		nil,
		nil,
		/* 52 Action3 <- <{ p.AddImport(text) }> */
		nil,
		/* 53 Action4 <- <{ p.AddRule(text) }> */
		nil,
		/* 54 Action5 <- <{ p.AddExpression() }> */
		nil,
		/* 55 Action6 <- <{ p.AddAlternate() }> */
		nil,
		/* 56 Action7 <- <{ p.AddNil(); p.AddAlternate() }> */
		nil,
		/* 57 Action8 <- <{ p.AddNil() }> */
		nil,
		/* 58 Action9 <- <{ p.AddSequence() }> */
		nil,
		/* 59 Action10 <- <{ p.AddPredicate(text) }> */
		nil,
		/* 60 Action11 <- <{ p.AddStateChange(text) }> */
		nil,
		/* 61 Action12 <- <{ p.AddPeekFor() }> */
		nil,
		/* 62 Action13 <- <{ p.AddPeekNot() }> */
		nil,
		/* 63 Action14 <- <{ p.AddQuery() }> */
		nil,
		/* 64 Action15 <- <{ p.AddStar() }> */
		nil,
		/* 65 Action16 <- <{ p.AddPlus() }> */
		nil,
		/* 66 Action17 <- <{ p.AddName(text) }> */
		nil,
		/* 67 Action18 <- <{ p.AddDot() }> */
		nil,
		/* 68 Action19 <- <{ p.AddAction(text) }> */
		nil,
		/* 69 Action20 <- <{ p.AddPush() }> */
		nil,
		/* 70 Action21 <- <{ p.AddSequence() }> */
		nil,
		/* 71 Action22 <- <{ p.AddSequence() }> */
		nil,
		/* 72 Action23 <- <{ p.AddPeekNot(); p.AddDot(); p.AddSequence() }> */
		nil,
		/* 73 Action24 <- <{ p.AddPeekNot(); p.AddDot(); p.AddSequence() }> */
		nil,
		/* 74 Action25 <- <{ p.AddAlternate() }> */
		nil,
		/* 75 Action26 <- <{ p.AddAlternate() }> */
		nil,
		/* 76 Action27 <- <{ p.AddRange() }> */
		nil,
		/* 77 Action28 <- <{ p.AddDoubleRange() }> */
		nil,
		/* 78 Action29 <- <{ p.AddCharacter(text) }> */
		nil,
		/* 79 Action30 <- <{ p.AddDoubleCharacter(text) }> */
		nil,
		/* 80 Action31 <- <{ p.AddCharacter(text) }> */
		nil,
		/* 81 Action32 <- <{ p.AddCharacter("\a") }> */
		nil,
		/* 82 Action33 <- <{ p.AddCharacter("\b") }> */
		nil,
		/* 83 Action34 <- <{ p.AddCharacter("\x1B") }> */
		nil,
		/* 84 Action35 <- <{ p.AddCharacter("\f") }> */
		nil,
		/* 85 Action36 <- <{ p.AddCharacter("\n") }> */
		nil,
		/* 86 Action37 <- <{ p.AddCharacter("\r") }> */
		nil,
		/* 87 Action38 <- <{ p.AddCharacter("\t") }> */
		nil,
		/* 88 Action39 <- <{ p.AddCharacter("\v") }> */
		nil,
		/* 89 Action40 <- <{ p.AddCharacter("'") }> */
		nil,
		/* 90 Action41 <- <{ p.AddCharacter("\"") }> */
		nil,
		/* 91 Action42 <- <{ p.AddCharacter("[") }> */
		nil,
		/* 92 Action43 <- <{ p.AddCharacter("]") }> */
		nil,
		/* 93 Action44 <- <{ p.AddCharacter("-") }> */
		nil,
		/* 94 Action45 <- <{ p.AddHexaCharacter(text) }> */
		nil,
		/* 95 Action46 <- <{ p.AddOctalCharacter(text) }> */
		nil,
		/* 96 Action47 <- <{ p.AddOctalCharacter(text) }> */
		nil,
		/* 97 Action48 <- <{ p.AddCharacter("\\") }> */
		nil,
		/* 98 Action49 <- <{ p.AddSpace(text) }> */
		nil,
		/* 99 Action50 <- <{ p.AddComment(text) }> */
		nil,
	}
	p.rules = _rules
	return nil
}
