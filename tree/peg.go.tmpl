// Code generated by {{.Generator}}. DO NOT EDIT.

{{.Comments}}

package {{.PackageName}}

import (
	{{range .Imports}}"{{.}}"
	{{end}}
)

const endSymbol rune = {{.EndSymbol}}

/* The rule types inferred from the grammar are below. */
type pegRule {{.PegRuleType}}

const (
	ruleUnknown pegRule = iota
	{{range .RuleNames}}rule{{.String}}
	{{end}}
)

var rul3s = [...]string {
	"Unknown",
	{{range .RuleNames}}"{{.String}}",
	{{end}}
}

type Uint interface {
	~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64
}

type token[U Uint] struct {
	pegRule
	begin, end U
}

func (t *token[_]) String() string {
	// \x1B[34m = blue
	// \x1B[m   = normal (disable color)
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

{{if .Ast}}
type node[U Uint] struct {
	token[U]
	up, next *node[U]
}

func (n *node[U]) print(w io.Writer, pretty bool, buffer string) {
	var printFunc func(n *node[U], depth int)
	printFunc = func(n *node[U], depth int) {
		for n != nil {
			for range depth {
				fmt.Fprint(w, " ")
			}
			rule := rul3s[n.pegRule]
			quote := strconv.Quote(string([]rune(buffer)[n.begin:n.end]))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if n.up != nil {
				printFunc(n.up, depth+1)
			}
			n = n.next
		}
	}
	printFunc(n, 0)
}

func (n *node[_]) Print(w io.Writer, buffer string) {
	n.print(w, false, buffer)
}

func (n *node[_]) PrettyPrint(w io.Writer, buffer string) {
	n.print(w, true, buffer)
}

type tokens[U Uint] struct {
	tree []token[U]
}

func (t *tokens[_]) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens[_]) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens[U]) AST() *node[U] {
	type element struct {
		node *node[U]
		down *element
	}
	tokenSlice := t.Tokens()
	var stack *element
	for _, token := range tokenSlice {
		if token.begin == token.end {
			continue
		}
		node := &node[U]{token: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens[_]) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens[_]) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens[_]) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens[U]) Add(rule pegRule, begin, end, index U) {
	tree, i := t.tree, int(index)
	newToken := token[U]{pegRule: rule, begin: begin, end: end}

	if i >= len(tree) {
		t.tree = append(tree, newToken)
		return
	}
	tree[i] = newToken
}

func (t *tokens[U]) Tokens() []token[U] {
	return t.tree
}
{{end}}

type {{.StructName}}[U Uint] struct {
	{{.StructVariables}}
	Buffer          string
	buffer	        []rune
	rules	        [{{.RulesCount}}]func() bool
	parse	        func(rule ...int) error
	reset	        func()
	Pretty          bool
{{if .Ast -}}
	disableMemoize  bool
	tokens[U]
{{end -}}
}

func (p *{{.StructName}}[_]) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *{{.StructName}}[_]) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int] textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length := len(positions)
	translations := make(textPositionMap, length)
	posIdx := 0
	line := 1
	symbol := 0

	slices.Sort(positions)

	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[posIdx] {
			translations[positions[posIdx]] = textPosition{line, symbol}
			for posIdx++; posIdx < length; posIdx++ {
				if i == positions[posIdx] {
					return translations
				}
			}
		}
		if posIdx >= length {
			break
		}
	}

	return translations
}

type parseError[U Uint] struct {
	p *{{.StructName}}[U]
	maxToken token[U]
}

func (e *parseError[U]) Error() string {
	tokenSlice, err := []token[U]{e.maxToken}, "\n"
	positions, p := make([]int, 2*len(tokenSlice)), 0
	for _, t := range tokenSlice {
		positions[p], p = int(t.begin), p+1
		positions[p], p = int(t.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, t := range tokenSlice {
		begin, end := int(t.begin), int(t.end)
		err += fmt.Sprintf(format,
			rul3s[t.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

{{if .Ast}}
func (p *{{.StructName}}[_]) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens.PrintSyntaxTree(p.Buffer)
	}
}

func (p *{{.StructName}}[_]) WriteSyntaxTree(w io.Writer) {
	p.tokens.WriteSyntaxTree(w, p.Buffer)
}

func (p *{{.StructName}}[_]) SprintSyntaxTree() string {
	var b bytes.Buffer
	p.WriteSyntaxTree(&b)
	return b.String()
}

{{if .HasActions}}
func (p *{{.StructName}}[_]) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, t := range p.Tokens() {
		switch t.pegRule {
		{{if .HasPush}}
		case rulePegText:
			begin, end = int(t.begin), int(t.end)
			text = string(_buffer[begin:end])
		{{end}}
		{{range .Actions}}case ruleAction{{.GetID}}:
			{{.String}}
		{{end}}
		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}
{{end}}
{{end}}

func Pretty[U Uint](pretty bool) func(*{{.StructName}}[U]) error {
	return func(p *{{.StructName}}[U]) error {
		p.Pretty = pretty
		return nil
	}
}

{{if .Ast -}}
func Size[U Uint](size int) func(*{{.StructName}}[U]) error {
	return func(p *{{.StructName}}[U]) error {
		p.tokens = tokens[U]{tree: make([]token[U], 0, size)}
		return nil
	}
}

func DisableMemoize[U Uint]() func(*{{.StructName}}[U]) error {
	return func(p *{{.StructName}}[U]) error {
		p.disableMemoize = true
		return nil
	}
}

type memo[U Uint] struct {
	Matched       bool
	Partial       []token[U]
}

type memoKey[U Uint] struct {
	Rule     U
	Position U
}
{{end -}}

func (p *{{.StructName}}[U]) Init(options ...func(*{{.StructName}}[U]) error) error {
	var (
		maxToken             token[U]
		position, tokenIndex U
		buffer               []rune
{{if .Ast -}}
		memoization          map[memoKey[U]]memo[U]
{{end -}}
{{if not .Ast -}}
{{if .HasPush -}}
		text string
{{end -}}
{{end -}}
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		maxToken = token[U]{}
		position, tokenIndex = 0, 0
{{if .Ast -}}
		memoization = make(map[memoKey[U]]memo[U])
{{end -}}

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer) - 1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
{{if .Ast -}}
	tree := p.tokens
{{end -}}
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
{{if .Ast -}}
		p.tokens = tree
{{end -}}
		if matches {
{{if .Ast -}}
			p.Trim(uint32(tokenIndex))
{{end -}}
			return nil
		}
		return &parseError[U]{p, maxToken}
	}

	add := func(rule pegRule, begin U) {
{{if .Ast -}}
		tree.Add(rule, begin, position, tokenIndex)
{{end -}}
		tokenIndex++
		if begin != position && position > maxToken.end {
			maxToken = token[U]{rule, begin, position}
		}
	}

{{if .Ast -}}
	memoize := func(rule U, begin U, tokenIndexStart U, matched bool) {
		if p.disableMemoize {
			return
		}
		key := memoKey[U]{rule, begin}
		if !matched {
			memoization[key] = memo[U]{Matched: false}
		} else {
			memoization[key] = memo[U]{
				Matched: true,
				Partial: slices.Clone(tree.tree[tokenIndexStart:tokenIndex]),
			}
		}
	}

	memoizedResult := func(m memo[U]) bool {
		if !m.Matched {
			return false
		}
		tree.tree = append(tree.tree[:tokenIndex], m.Partial...)
		tokenIndex += U(len(m.Partial))
		position = m.Partial[len(m.Partial)-1].end
		if tree.tree[tokenIndex-1].begin != position && position > maxToken.end {
			maxToken = tree.tree[tokenIndex-1]
		}
		return true
	}
{{end -}}

	{{if .HasDot}}
	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}
	{{end}}

	{{if .HasString}}
	matchString := func(s string) bool {
		i := position
		for _, c := range s {
			if buffer[i] != c {
				return false
			}
			i++
		}
		position = i
		return true
	}
	{{end}}

	_rules = [...]func() bool {
		nil,
